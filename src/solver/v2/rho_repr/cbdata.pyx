# cython: profile=True

###
# Read CB data out of a file and convolve it with a derivative tensor
# corresponding depending on 'sigma', the dependence of the external dimension.
# 
#  S. El-Showk August 2013
#
####cython: profile=False

from libc.stdlib cimport malloc, free
from libc.stdio cimport stdout, sprintf, fprintf

from c_mpfr cimport *
from c_mpfi cimport * 
cimport c_polyval 

import solver.v2.mpfr_array.mpfr_array as mpfr_array 
cimport solver.v2.mpfr_array.mpfr_array as mpfr_array 

import solver.v2.prec_float.prec_float as PF
cimport solver.v2.prec_float.prec_float as PF

import utils.logging as log
import version

import numbers
import numpy as np
#from matplotlib.pyplot import *

from math import factorial as fac

defprec=212

# this should be moved to some universal defintion
def pf(x):
    return PF.prec_float(x,prec=defprec)



def pochhammer (delta , n):
    """Compute the pochhammer symbol (delta)_n where delta is a pf."""
    if n == 0:
        return pf(1)
    else:
        ret = pf(1)
        for i in range(n):
            ret = ret * (delta+pf(i))
        return ret  
        


def coeff_tensor (ds0, nmax, mmax): 
    """ returns the tensor t which converts derivatives h[n][m] with n<=nmax, m<= mmax+2*(nmax-n) 
    into coefficients to be fed into linear programming. Format of the tensor
    linprog[n][m] = t[n][m][n1][m1] h[n1][m1]
    Coefficients with even m are returned zero which is their theoretical value which is not computed, just set"""
    ds = pf(ds0)
    # these are derivatives of ((1/2-t)^2-s)^ds
    a = [[ pf((-1)**(m+n))*pochhammer(ds+pf(-n+1),n)*
        pochhammer(pf(2)*ds+pf(-2*n-m+1),m)/pf(2)**(pf(2)*ds+pf(-2*n-m)) 
            for m in range(mmax +2*(nmax-n)+1) ] for n in range(nmax+1)] 
    t = [[
        [[ pf(0) if m%2==0 or m1>m or n1>n else a[n-n1][m-m1]\
        /pf(str(fac(n-n1)*fac(m-m1)*fac(n1)*fac(m1))) #*fac(n)*fac(m) if want to compute derivatives
        # current version computes Taylor coefficients
            for m1 in range(mmax +2*(nmax-n1)+1) ] for n1 in range(nmax+1)]
        for m in range(mmax +2*(nmax-n)+1) ] for n in range(nmax+1)]   
    return t



###########################################################
# each conformal block component has the form
# rho^x (p(x-delta0) +q(x)). x= operator dimension, rho = 3-sqrt(8)
# p(x) is a polynomial of degree 2 nmax + mmax
# q(x) is a rational function of the form sum c(i)/(x-x(i))
#(simple poles only - this condition won't work in d=2,4)

cdef class CBdata:
    """Read in raw (unconvolved) CB data from a file generated by mathematica
    which contains the coefficients of a rational functions.  For each spin we
    have one rational function for each derivative combination (plen below).
    Each function has a polynomial part and a part with poles.  We seperately
    store the coefficients of the polynomial part for each function while the
    poles are stores in two steps:  first we store the location of _all_ poles
    that appear for a given spin (but accross all derivative components).  Then
    for each derivative component we store a list of coefficients of each pole
    (which can in principle be zero if a pole does not exist for a given
    component though this never seems to happen).
    
    The file format is as follows:

        nmax
        mmax
        lmax
        prec
        plen
        (for each spin)
        ncoeffP  (number of coefficients of polynomial -- fixed accress components) 
        component (x plen x ncoeffP)
        npoles  (number of poles -- fixed across components)
        pole locations  (x npoles)
        pole coeff ( x plen x npoles)
    """

    cdef public PF.prec_float eps
    cdef public int lmax
    cdef public int nmax
    cdef public int mmax
    cdef public int prec
    cdef public int plen
    cdef public dict CBs
    cdef public PF.prec_float rho
    cdef public PF.prec_float ds
    cdef public PF.prec_float tmp # Carlos edit

    def __init__(self, FILE):
        self.CBs = {}       
        self.eps = PF.prec_float(FILE.readline()) #spacetime dimension (d-2)/2
        print 'read in file with eps = %s'%str(self.eps)
        self.nmax=int(FILE.readline())
        self.mmax=int(FILE.readline())
        self.lmax=int(FILE.readline())
        #initialize from file
        self.prec = int(FILE.readline()) #precision
        defprec=self.prec
        self.plen = int(FILE.readline()) #vector length
        #print 'plen: ', self.plen
        #self.delta0 = PF.prec_float(FILE.readline(),self.prec)
        #point around which the polynomials are expanded
        #chosen at the unitarity bound
        for l in range(0, self.lmax+1, 2): 
            #print 'l=',l
            self.CBs[l]=CBLdata(FILE, l, self.plen, self.prec) 
        self.rho = PF.prec_float(3,self.prec)- PF.sqrt(PF.prec_float(8,self.prec))
        #initialize rho=3-sqrt(8) for further use
   
    # ds should be a pf
    def set_ds(self, ds):
        """Convolve CB data with derivative tensor for given ds (in float
        format)."""
        self.ds=ds
        #print 'nmax,mmax=',self.nmax,self.mmax
        for l in range(0, self.lmax+1, 2):  
            # self.CBs[l].set_ds(ds, self.nmax, self.mmax) # Carlos edit
            self.CBs[l].set_ds(ds, self.nmax, self.mmax)


    def unitCB(self):
        tt=coeff_tensor(self.ds, self.nmax, self.mmax)
        return mpfr_array.array(
            [tt[n][m][0][0] 
                for n in range(self.nmax+1)
                for m in range(1, 2*(self.nmax -n) + self.mmax+1,2) ])


#
# Single spin
#
cdef class CBLdata:
    cdef public mpfr_array.ndarray Ps,poles,polecoeffs
    cdef public mpfr_array.ndarray sigPs,sigpolecoeffs
    cdef public mpfr_array.ndarray goodpoles,goodpolecoeffs
    cdef public int plen, l, prec, CBlen
    cdef public int ncoeffsP, npoles
    cdef public PF.prec_float delta0
    
    
    def __init__(self, FILE, l, plen, prec):
        self.prec = prec
        self.l=l
        # The number of derivative components
        self.plen=plen
        # unitarity bound
        self.delta0 = pf(FILE.readline())
        # this is the number of coefficients of the polynomials
        # (given by the max degree of the polynomials accross all components)
        self.ncoeffsP = int(FILE.readline()) 
        Pstring = [ [FILE.readline() for i in range(self.ncoeffsP)] for n in
                range(self.plen)]
        self.Ps = mpfr_array.array(Pstring)
        # number of different locations of poles across all components
        self.npoles = int(FILE.readline()) 
        poles_string = [ FILE.readline() for i in range(self.npoles)] 
        self.poles = mpfr_array.array(poles_string)
        # read the poles x(i) and store in mpfr_array. Poles are the same for each component
        polecoeffstring = [ [FILE.readline() for i in range(self.npoles)] for n in
                range(self.plen)]
        self.polecoeffs = mpfr_array.array(polecoeffstring)
        # read the coefficients of the poles c(i) (different for each of plen components)
        #and store in mpfr_array
 
    def getCBInds(self,nmax, mmax):
        """return a map of (n,m)-->i indices where m starts at 1 and has step 2"""
        CBinds={}
        i=0
        for n in range(nmax+1):
            for m in range(1, mmax +2*(nmax-n)+1,2):
                CBinds[(n, m)]=i
                i+=1
        return CBinds

    def getInds(self, nmax, mmax):
        """return a map of (n,m)-->i indices where m starts at 0 and is step 1"""
        inds={}
        i=0
        for n in range(nmax+1):
            for m in range(0, mmax +2*(nmax-n)+1):
                inds[(n, m)]=i
                i+=1
        return inds


    # ds should be a pf
    cpdef set_ds(self, ds, nmax, mmax):
        cdef mpfr_t tmp
        cdef int n1m1i,nmi
        log.stats('precoeff tensor')
        tt=coeff_tensor(ds, nmax, mmax)
        log.stats('post tensor')
        CBinds=self.getCBInds(nmax, mmax)
        self.CBlen=len(CBinds.keys())
        self.sigPs= mpfr_array.array([[0 for i in range(self.ncoeffsP)] for i in
            range(self.CBlen)])
        self.sigpolecoeffs= mpfr_array.array([[0 for i in range(self.npoles)] for i in
            range(self.CBlen)])
        inds=self.getInds(nmax,mmax)
        log.stats('before tmp')
        #print sorted(CBinds)
        #print sorted(inds)
        # for some reason 'sum' doesn't work on lists of pf's hence this ugly
        # code
        #tmp=mpfr_array.ndarray()
        mpfr_init2(tmp, 212)
        log.stats('**BEFORE LOOP')
        #log.debug('num coeffs,poles (%d,%d)'%(self.ncoeffsP, self.npoles))
        for n in range(nmax+1):
            for m in range(1,mmax +2*(nmax-n)+1, 2):
                #print t[n][m]
                for n1 in range(n+1):
                    for m1 in range(m+1):
                        vl=bytes(tt[n][m][n1][m1])
                    
                        for i in range(self.ncoeffsP):
                            mpfr_set_str(tmp, vl, 10, MPFR_RNDD)
                           # tmp.assign_prec_float(tt[n][m][n1][m1])  # copies the data from tt[n][m][n1][m1] to tmp
                            n1m1i= inds[(n1,m1)]*self.Ps.strides[0] + i
                            nmi= CBinds[(n,m)]*self.sigPs.strides[0] + i
                            mpfr_mul(tmp, tmp,
                                    self.Ps.data[n1m1i], MPFR_RNDD)
                            mpfr_add(self.sigPs.data[nmi], self.sigPs.data[nmi],
                                    tmp, MPFR_RNDD)
                        for i in range(self.npoles):
                            mpfr_set_str(tmp, vl, 10, MPFR_RNDD)
                            #tmp.assign_prec_float(tt[n][m][n1][m1])  # copies the data from tt[n][m][n1][m1] to tmp
                            n1m1i=inds[(n1,m1)]*self.polecoeffs.strides[0] + i
                            nmi=CBinds[(n,m)]*self.sigpolecoeffs.strides[0] + i
                            mpfr_mul(tmp, tmp,
                                    self.polecoeffs.data[n1m1i], MPFR_RNDD)
                            # think this line is redundant -- just set in last
                            # line?
                            mpfr_add(self.sigpolecoeffs.data[nmi],
                                    self.sigpolecoeffs.data[nmi], tmp,
                                    MPFR_RNDD)
        log.stats('**AFTER LOOP')
        mpfr_clear(tmp)
        # remove poles with several coefficients that are too small
        # print("sigpolecoeffs %s" %(version.to_double(self.sigpolecoeffs)))
        self.cull_poles(nmax, mmax)
        log.stats('after cull')

    # ds should be a pf
#     def set_ds_old(self, ds, nmax, mmax):
#         cdef mpfr_t tmp
#         log.stats('precoeff tensor')
#         tt=coeff_tensor(ds, nmax, mmax)
#         log.stats('post tensor')
#         CBinds=self.getCBInds(nmax, mmax)
#         self.CBlen=len(CBinds.keys())
#         self.sigPs= mpfr_array.array([[0 for i in range(self.ncoeffsP)] for i in
#             range(self.CBlen)])
#         self.sigpolecoeffs= mpfr_array.array([[0 for i in range(self.npoles)] for i in
#             range(self.CBlen)])
#         inds=self.getInds(nmax,mmax)
#         log.stats('before tmp')
#         #print sorted(CBinds)
#         #print sorted(inds)
#         # for some reason 'sum' doesn't work on lists of pf's hence this ugly
#         # code
#         #tmp=mpfr_array.ndarray()
#         mpfr_init2(tmp, 212)
#         log.stats('**before loop')
#         for n in range(nmax+1):
#             for m in range(1,mmax +2*(nmax-n)+1, 2):
#                 #print t[n][m]
#                 for n1 in range(n+1):
#                     for m1 in range(m+1):
#                         #psn1m1=self.Ps[inds[(n1,m1)]]
#                         #psnm=self.Ps[inds[(n,m)]]
#                         #polen1m1=self.polecoeffs[inds[(n1,m1)]]
#                         #polenm=self.sigpolecoeffs[CBinds[(n,m)]]
#                         for i in range(self.ncoeffsP):
#                             vl=str(tt[n][m][n1][m1])
#                             mpfr_set_str(tmp, vl, 10, MPFR_RNDD)
#                             #self.sigPs[CBinds[(n,m)]][i] +=\
#                             #        (tmp*self.Ps[inds[(n1,m1)]][i])
#                             #mpfr_array.mult_assign(tmp, tmp,psn1m1[i])
#                             #mpfr_array.add_assign(psnm[i], psnm[i], tmp)
#                             n1m1i= inds[(n1,m1)]*self.Ps.strides[0] + i
#                             nmi= CBinds[(n,m)]*self.sigPs.strides[0] + i
#                             mpfr_mul(tmp, tmp,
#                                     self.Ps.data[n1m1i], MPFR_RNDD)
#                             mpfr_add(self.sigPs.data[nmi], self.sigPs.data[nmi],
#                                     tmp, MPFR_RNDD)
#                                     #self.sigPs.data[nmi], MPFR_RNDD)
#                         for i in range(self.npoles):
#                             vl=str(tt[n][m][n1][m1])
#                             mpfr_set_str(tmp, vl, 10, MPFR_RNDD)
#                             #mpfr_set(tmp, tt[n][m][n1][m1].data, MPFR_RNDD)
#                             #self.sigpolecoeffs[CBinds[(n,m)]][i] +=\
#                             #        (tmp*self.polecoeffs[inds[(n1,m1)]][i])
#                             #mpfr_array.mult_assign(tmp, tmp, polen1m1[i])
#                             #mpfr_array.add_assign(polenm[i], polenm[i], tmp)
#                             n1m1i=inds[(n1,m1)]*self.polecoeffs.strides[0] + i
#                             nmi=CBinds[(n,m)]*self.sigpolecoeffs.strides[0] + i
#                             mpfr_mul(tmp, tmp,
#                                     self.polecoeffs.data[n1m1i], MPFR_RNDD)
#                             # think this line is redundant -- just set in last
#                             # line?
#                             mpfr_add(self.sigpolecoeffs.data[nmi],
#                                     self.sigpolecoeffs.data[nmi], tmp,
#                                     MPFR_RNDD)
#         mpfr_clear(tmp)
#         log.stats('**after loop')
#         # remove poles with several coefficients that are too small
#         self.cull_poles(nmax, mmax)
#         log.stats('after cull')


    # ds should be a pf
#     def set_ds_old_old(self, ds, nmax, mmax):
#         log.stats('precoeff tensor')
#         tt=coeff_tensor(ds, nmax, mmax)
#         log.stats('post tensor')
#         CBinds=self.getCBInds(nmax, mmax)
#         self.CBlen=len(CBinds.keys())
#         self.sigPs= mpfr_array.array([[0 for i in range(self.ncoeffsP)] for i in
#             range(self.CBlen)])
#         self.sigpolecoeffs= mpfr_array.array([[0 for i in range(self.npoles)] for i in
#             range(self.CBlen)])
#         inds=self.getInds(nmax,mmax)
#         log.stats('before loop')
#         #print sorted(CBinds)
#         #print sorted(inds)
#         # for some reason 'sum' doesn't work on lists of pf's hence this ugly
#         # code
#         for n in range(nmax+1):
#             for m in range(1,mmax +2*(nmax-n)+1, 2):
#                 #print t[n][m]
#                 for n1 in range(n+1):
#                     for m1 in range(m+1):
#                         for i in range(self.ncoeffsP):
#                         #print mpfr_array.array([str(t[n][m][n1][m1])])
#                             self.sigPs[CBinds[(n,m)]][i] +=\
#                                 (mpfr_array.array([str(tt[n][m][n1][m1])]) *
#                                     self.Ps[inds[(n1,m1)]][i])
#                         for i in range(self.npoles):
#                             self.sigpolecoeffs[CBinds[(n,m)]][i] +=\
#                                 (mpfr_array.array([str(tt[n][m][n1][m1])]) *
#                                     self.polecoeffs[inds[(n1,m1)]][i])
#         log.stats('after loop')
#         # remove poles with several coefficients that are too small
#         self.cull_poles(nmax, mmax)
#         log.stats('after cull')


    def mpfrabs(self, ar):
        """this is a horrible kludge"""
        z=mpfr_array.array(["0"])
        if ar >= z:
            return ar
        else:
            return -ar

    def cull_poles(self, nmax, mmax):
        cuttoff=mpfr_array.array([10e-30])
        CBinds=self.getCBInds(nmax, mmax)
        if mmax % 2 ==0:
            m=mmax-1
        else:
            m=mmax
        indlist=[CBinds[(nmax,m)], CBinds[(0, 2 * nmax+m)], CBinds[(0,1)]]
 
        goodpolesind =[]
        for i in range(self.npoles):
            nabove=0
            for j in indlist:
                if self.mpfrabs(self.sigpolecoeffs[j][i]) >= cuttoff:
                    
                    nabove+=1
            # if at least one is above the cuttoff we keep this pole
            if nabove > 0:
                goodpolesind += [i]
        #print("self.poles %s"%(version.to_double(self.poles) ))
        #self.goodpoles = mpfr_array.array([str(self.poles[i]) for i in goodpolesind])
        self.goodpoles = mpfr_array.array([version.to_double(self.poles[i]) for i in goodpolesind])       # Carlos edit 
        self.goodpolecoeffs= mpfr_array.array([[0 for i in goodpolesind] for j in
            range(self.CBlen)])
        for i in range(len(goodpolesind)):
            for j in range(self.CBlen):
                #print 'p:', self.sigpolecoeffs[j][i]
                self.goodpolecoeffs[j][i] = self.sigpolecoeffs[j][goodpolesind[i]] 
#        # print goodpolesind

